## 영속성 컨텍스트

* 엔티티를 영구 저장하는 환경
* 엔티티 매니저를 통해 접근

> 영속성 컨텍스트의 이점

* 1차 캐시
  * 조회 시 영속 컨텍스트안에서 1차 캐시를 조회 후 해당 엔티티가 있을 경우 캐시를 조회 해 온다. 엔티티가 없을 경우 데이터베이스에서 조회 해 온다.
  * 데이터베이스 트랜잭션 내부에서 만들고 종료

* 동일성 보장
  * 자바 컬렉션에서 값을 가져오는 것 처럼 동일성을 보장한다

* 쓰기 지연 
  * 쓰기 지연 SQL 저장소에 SQL을 모아뒀다가 commit() 시점에 쿼리들을 실행
* 변경 감지(dirty-checking)
  * 1차 캐시안에는 `@Id`, `Entity` , `스냅샷` 이 있다. 여기서 스냅샷 은 최초로 영속성 컨텍스트(1차캐시)에 들어오는순간 스냅샷을 찍어서 저장해둔다.
  * JPA는 트랜잭션이 커밋(commit)되는 순간 엔티티와 스냅샷을 모두 비교한다. 
  * 변경된 것이 있을 경우 쓰기지연 SQL 저장소 에 업데이트 쿼리를 저장하고 수행하게 된다. 

### 플러시

영속성 컨텍스트를 플러시 하는 방법
1. em.flush()  : 직접 호출
2. 트랜잭션 커밋: 플러시 자동 호출
3. JPQL 쿼리 실행: 플러시 자동 호출

## 엔티티 매핑, 연관관계

### @Enumerated

* 자바 Enum 타입을 매핑할 때 사용
* ORDINAL 타입을 사용하지 말자.
    → enum타입이 추가,변경,삭제 되어 순서가 달라질 경우 사이드 이펙트가 생긴다. 
* EnumType.ORDINAL: ENUM 순서를 데이터베이스에 저장
* EnumType.STRING: ENUM 이름을 데이터베이스에 저장


### 연관관계 주인

* 양방향 매핑 규칙
  * 객체의 두 관계중 하나를 연관관계의 주인으로 지정
  * 연관관계의 주인만이 외래 키를 관리(등록, 수정)
  * 주인이 아닌쪽은 읽기만 가능
    * 주인이 아닌 쪽에서 값을 넣어도 반영되지 않음
  * 주인이 아니면 mappedBy속성으로 주인을 지정한다. 
  * 외래 키가 있는 곳을 주인으로 지
  * 양방향일시 연관관계 편의 메서드를 작성할 것

### 다대일
* 외래 키가 있는 쪽이 연관관계의 주인

### 일대다
일(One)이 연관관계의 주인이다  →  권장하는 방법은 아니다 실무에서도 거의 사용되지 않음. 
> 결론: 기본은 다대일(N:1)로 구현하다 필요에 의해 양방향 다대일(N:1) 관계를 수립하도록 하자.

### 일대일
* 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
* 외래키에 데이터베이스 유니크 제약조건 추가

### 상속관계 매핑
1. 조인 전략
![image](https://user-images.githubusercontent.com/97269799/219606796-1d1e6aba-4f02-40a9-ac39-828ca89fa591.png)
* 장점
  * 정규화도 되어있고, 제약조건을 부모에 걸어 맞출 수 있다.
* 단점
  * 조회시 조인이 많을 경우 성능 저하
  * 조회 쿼리가 복잡함.
2. 단일 테이블 전략
![image](https://user-images.githubusercontent.com/97269799/219607205-c39e7dc5-a605-46bc-8445-337ed41de639.png)
* 논리모델을 한 테이블로 합쳐버리는 방법.
* 한 테이블에 다 넣어 놓고 어떤 테이블인지 구분하는 컬럼(ex:DTYPE)을 통해 구분한다.

* 장점
  * 조인이 필요 없기에 일반적으로 조회 성능이 빠름
  * 조회 쿼리가 단순함.
* 단점
  * 자식 엔티티가 매핑한 컬럼은 모두 nullable 해야 한다.
  * 단일 테이블에 모든 것을 저장하기에 테이블이 커질 수 있고 상황에 따라서
  * 조회성능이 더 느려질 수 있다.

#### 주요 어노테이션
`@inheritance` strategy = JOINED(조인전략), SINGLE_TABLE(단일테이블)

`@DiscriminatorColumn` name = ~~   컬럼명 (DTYPE 이 기본)

`@DiscriminatorValue` value = ~~   DTYPE 에 들어갈때 이름 설


### `@MappedSuperclass`
* 상속관계 매핑이 아니다.
* 엔티티도 아니고, 테이블과 매핑되지도 않는다.
* 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공 -> 컬럼만 내려주는 역할
* 직접 생성해서 사용할 일이 없으므로 추상클래스 추천

## 즉시로딩, 지연로딩

### 프록시
* 실제 클래스를 상속받아서 만들어짐
* 실제 클래스와 겉 모양이 같다.
* 프록시는 처음 사용할 때 한 번만 초기화
* 프록시 객체를 초기화 할 때 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해 실제 엔티티에 접근 가능

### 지연로딩
> fetch = FetchType.LAZY
* 연관관계에 있는 다른 엔티티를 사용하는 빈도수가 낮을 경우 지연로딩을 사용해 불필요한 엔티티 조회를 막을 수 있다.
* 엔티티를 가져올 때 연관관계에 해당하는 엔티티는 프록시로 가져옴. 실제 사용할때 select 쿼리

### 즉시로딩
> fetch = FetchType.EAGER
* Member를 가져오는 시점에서 연관관계에 있는 Team까지 바로 가져오는 것을 즉시 로딩이라 한다. 
* 즉시로딩은 JPQL 에서 `N + 1 의 문제` 를 일으킨다.

#### 결론
1. 모든 연관관계에 지연 로딩을 사용하자.
2. 실무에서 즉시 로딩을 사용하지 마라.
3. JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라.


### 영속성 전이와 고아객체
* `parent` 만 persist 하면 `child` 도 전부 persist 
* CASCADE의 종류
 * ALL: 모두 적용(모든 곳에서 맞춰야 하면 해당 옵션)
 * PERSIST: 영속(저장할 때만 사용 할 것이면 해당 옵션)
 * REMOVE: 삭제
* 사용해야 할 때
 * 라이프 사이클이 동일할 때
 * 단일 소유자 관계일 때 


## 기본값 타입
> 스프링에선 크게 `엔티티 타입` 과 `값 타입` 으로 나뉜다

### 임베디드 타입

* 새로운 값 타입을 직접 정의할 수 있다.
* 임베디드 타입 사용법
 * @Embeddable: 값 타입을 정의하는 곳에 표시
 * @Embedded: 값타입을 사용하는 곳에 표시
 * 기본 생성자 필수
 * `장점`
 1. 재사용
   Period나 Address는 다른 객체에서도 사용 할 수 있어 재사용성을 높힌다.
 2. 높은 응집도
 3. Period.isWork()처럼 해당 값 타입만 사용하는 의미있는 메소드를 만들 수 있음.
* 임베디드 타입을 통해 `객체를 분리`하더라도 테이블은 `하나만 매핑`된다.
![image](https://user-images.githubusercontent.com/97269799/219611625-858a236b-50ee-4d2a-a25a-6e8cf1b97d0a.png)

#### 임베디드 타입 사용 시 주의점
1. 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다.
2. 값(인스턴스)을 복사해서 사용한다.
3. 값 타입은 불변 객체(immutable object)로 설계해야 한다. == `setter` 를 없애는 것
     불변 객체: 생성 시점 이후 절대 값을 변경할 수 없는 객체
4. 임베디드 타입은 객체이기 때문에 `동일성 비교`시 false 가 뜬다. `동등성 비교`를 해야함 -> equals() 를 사용



## 엔티티 설계시 주의점
* 엔티티에서는 가급적 Setter를 사용하지 말자.
 * Setter가 열려있으면 변경 포인트가 너무 많아 유지보수가 어렵다.
* 모든 연관관계는 지연로딩으로 설정
 * `ManyToOne`이나  `OneToOne`과 같은 xxxToOne 매핑은 기본 전략이 EAGER이므로 수동으로 LAZE로 바꾸도록 해야 한다. 
* 컬렉션은 필드에서 초기화 하자.
* 비즈니스 로직은 엔티티 안에 있는것이 응집도를 높힐 수 있다.(= 객체지향 설계) (ex 상품을 샀다면 재고도 감소하게 엔티티에 로직 작성) 이를 `도메인 모델 패턴` 이라 한다.

### 서비스 계층 개발시
* 클래스단에 `@Transactional(readOnly = true)` 을 걸어주고 필요한 곳에 따로 @Transactional 을 써줌 

### 테스트시
* 예외 발생 여부를 테스트하고싶을때는 @Test annotation의 expected = Exception.class 속성을 사용하면 된다.
   → @Test(expected = IllegalStateException.class)
   
   
## 변경 감지와 병합
1. 엔티티를 변경할 때는 항상 변경 감지를 사용하도록 하자.
2. 컨트롤러에서 어설프게 엔티티를 생성하지 마세요.
3. 트랜잭션이 있는 서비스 계층에 식별자와 변경할 데이터를 명확하게 전달하자.(파라미터 or DTO)
4. 트랜잭션 커밋 시점에 변경감지가 실행됩니다.

## 컨트롤러에서 주의사항
* 커맨드성 로직들은 Controller에서는 식별자만 넘겨주고, Service단에서 핵심 로직들을 수행하는게 좋다.
* 트랜잭션 내부에서 관리되고 엔티티들이 영속상태인데, Controller단에서 **엔티티를 파라미터로 받으면, 해당 엔티티는 준영속 상태**가 되기때문에 부작용(sideEffect)를 유도할 수 있다.
