## 영속성 컨텍스트

* 엔티티를 영구 저장하는 환경
* 엔티티 매니저를 통해 접근

> 영속성 컨텍스트의 이점

* 1차 캐시
  * 조회 시 영속 컨텍스트안에서 1차 캐시를 조회 후 해당 엔티티가 있을 경우 캐시를 조회 해 온다. 엔티티가 없을 경우 데이터베이스에서 조회 해 온다.
  * 데이터베이스 트랜잭션 내부에서 만들고 종료

* 동일성 보장
  * 자바 컬렉션에서 값을 가져오는 것 처럼 동일성을 보장한다

* 쓰기 지연 
  * 쓰기 지연 SQL 저장소에 SQL을 모아뒀다가 commit() 시점에 쿼리들을 실행
* 변경 감지(dirty-checking)
  * 1차 캐시안에는 `@Id`, `Entity` , `스냅샷` 이 있다. 여기서 스냅샷 은 최초로 영속성 컨텍스트(1차캐시)에 들어오는순간 스냅샷을 찍어서 저장해둔다.
  * JPA는 트랜잭션이 커밋(commit)되는 순간 엔티티와 스냅샷을 모두 비교한다. 
  * 변경된 것이 있을 경우 쓰기지연 SQL 저장소 에 업데이트 쿼리를 저장하고 수행하게 된다. 

### 플러시

영속성 컨텍스트를 플러시 하는 방법
1. em.flush()  : 직접 호출
2. 트랜잭션 커밋: 플러시 자동 호출
3. JPQL 쿼리 실행: 플러시 자동 호출

## 엔티티 매핑, 연관관계

### @Enumerated

* 자바 Enum 타입을 매핑할 때 사용
* ORDINAL 타입을 사용하지 말자.
    → enum타입이 추가,변경,삭제 되어 순서가 달라질 경우 사이드 이펙트가 생긴다. 
* EnumType.ORDINAL: ENUM 순서를 데이터베이스에 저장
* EnumType.STRING: ENUM 이름을 데이터베이스에 저장


### 연관관계 주인

* 양방향 매핑 규칙
  * 객체의 두 관계중 하나를 연관관계의 주인으로 지정
  * 연관관계의 주인만이 외래 키를 관리(등록, 수정)
  * 주인이 아닌쪽은 읽기만 가능
    * 주인이 아닌 쪽에서 값을 넣어도 반영되지 않음
  * 주인이 아니면 mappedBy속성으로 주인을 지정한다. 
  * 외래 키가 있는 곳을 주인으로 지
  * 양방향일시 연관관계 편의 메서드를 작성할 것

### 다대일
* 외래 키가 있는 쪽이 연관관계의 주인

### 일대다
일(One)이 연관관계의 주인이다  →  권장하는 방법은 아니다 실무에서도 거의 사용되지 않음. 
> 결론: 기본은 다대일(N:1)로 구현하다 필요에 의해 양방향 다대일(N:1) 관계를 수립하도록 하자.

### 일대일
* 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
* 외래키에 데이터베이스 유니크 제약조건 추가

### 상속관계 매핑
1. 조인 전략
![image](https://user-images.githubusercontent.com/97269799/219606796-1d1e6aba-4f02-40a9-ac39-828ca89fa591.png)
* 장점
  * 정규화도 되어있고, 제약조건을 부모에 걸어 맞출 수 있다.
* 단점
  * 조회시 조인이 많을 경우 성능 저하
  * 조회 쿼리가 복잡함.
2. 단일 테이블 전략
![image](https://user-images.githubusercontent.com/97269799/219607205-c39e7dc5-a605-46bc-8445-337ed41de639.png)
* 논리모델을 한 테이블로 합쳐버리는 방법.
* 한 테이블에 다 넣어 놓고 어떤 테이블인지 구분하는 컬럼(ex:DTYPE)을 통해 구분한다.

* 장점
  * 조인이 필요 없기에 일반적으로 조회 성능이 빠름
  * 조회 쿼리가 단순함.
* 단점
  * 자식 엔티티가 매핑한 컬럼은 모두 nullable 해야 한다.
  * 단일 테이블에 모든 것을 저장하기에 테이블이 커질 수 있고 상황에 따라서
  * 조회성능이 더 느려질 수 있다.

#### 주요 어노테이션
`@inheritance` strategy = "JOINED"(조인전략), "SINGLE_TABLE"(단일테이블)`
`@DiscriminatorColumn` name = "~~~" 컬럼명 (DTYPE 이 기본)
`@DiscriminatorValue` value = "~~~" DTYPE 에 들어갈때 이름 설


### `@MappedSuperclass`
